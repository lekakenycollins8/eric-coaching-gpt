import { openai } from '@/services/openai';
import { DEFAULT_MODEL } from '@/config/openai';
import { FollowupCategoryType } from '@/utils/followupUtils';
import { PILLAR_FOLLOWUP_PROMPT, PILLAR_FOLLOWUP_SYSTEM_MESSAGE } from '@/config/prompts/pillarFollowupPrompt';
import { WORKBOOK_FOLLOWUP_PROMPT, WORKBOOK_FOLLOWUP_SYSTEM_MESSAGE } from '@/config/prompts/workbookFollowupPrompt';

/**
 * Extract a section from the generated text by heading
 * @param text The full text to extract from
 * @param sectionHeading The heading to look for
 * @param nextSectionHeading Optional next section heading to limit extraction
 * @returns The extracted section text
 */
export function extractSection(text: string, sectionHeading: string, nextSectionHeading?: string): string {
  // Find the section heading
  const sectionRegex = new RegExp(`## ${sectionHeading}\\s*\\n([\\s\\S]*?)(?:## ${nextSectionHeading}|$)`, 'i');
  const match = text.match(sectionRegex);
  
  if (match && match[1]) {
    return match[1].trim();
  }
  
  return '';
}

/**
 * Interface for the diagnosis response structure
 */
export interface FollowupDiagnosisResponse {
  summary: string;
  situationAnalysis: string;
  strengthsAnalysis: string;
  growthAreasAnalysis: string;
  actionableRecommendations: string;
  pillarRecommendations?: string;
  followupRecommendation: string;
}

/**
 * Generate a follow-up diagnosis based on the follow-up type and context
 * @param followupType The type of follow-up ('pillar' or 'workbook')
 * @param contextData The context data for the follow-up
 * @returns The generated diagnosis response
 */
export async function generateFollowupDiagnosis(
  followupType: FollowupCategoryType,
  contextData: any
): Promise<FollowupDiagnosisResponse> {
  try {
    // Select the appropriate prompt and system message based on follow-up type
    const promptTemplate = followupType === 'pillar' ? PILLAR_FOLLOWUP_PROMPT : WORKBOOK_FOLLOWUP_PROMPT;
    const systemMessage = followupType === 'pillar' ? PILLAR_FOLLOWUP_SYSTEM_MESSAGE : WORKBOOK_FOLLOWUP_SYSTEM_MESSAGE;
    
    // Format the prompt with context data
    const formattedPrompt = promptTemplate
      .replace('{{originalAnswers}}', JSON.stringify(contextData.originalAnswers, null, 2))
      .replace('{{followupAnswers}}', JSON.stringify(contextData.followupAnswers, null, 2))
      .replace('{{originalDiagnosis}}', JSON.stringify(contextData.originalDiagnosis, null, 2))
      .replace('{{worksheetTitle}}', contextData.worksheetTitle || 'Unknown Worksheet')
      .replace('{{worksheetDescription}}', contextData.worksheetDescription || 'No description available')
      .replace('{{timeElapsed}}', contextData.timeElapsed?.toString() || 'Unknown');
    
    // If it's a pillar follow-up, include the pillar-specific context
    if (followupType === 'pillar' && contextData.pillarId) {
      const pillarContext = `This follow-up is specifically for the "${contextData.pillarTitle || 'Unknown'}" pillar (ID: ${contextData.pillarId}).`;
      formattedPrompt.replace('{{additionalContext}}', pillarContext);
    } else {
      formattedPrompt.replace('{{additionalContext}}', '');
    }
    
    // Call the OpenAI API
    const response = await openai.chat.completions.create({
      model: DEFAULT_MODEL,
      messages: [
        { role: 'system', content: systemMessage },
        { role: 'user', content: formattedPrompt }
      ],
      temperature: 0.7,
      max_tokens: 2500
    });
    
    // Extract the generated text
    const generatedText = response.choices[0]?.message?.content || '';
    
    // Parse the response into a structured diagnosis
    return parseFollowupDiagnosis(generatedText, followupType);
  } catch (error) {
    console.error('Error generating follow-up diagnosis:', error);
    throw new Error('Failed to generate follow-up diagnosis');
  }
}

/**
 * Parse the generated text into a structured diagnosis response
 * @param generatedText The raw text generated by the AI
 * @param followupType The type of follow-up ('pillar' or 'workbook')
 * @returns The structured diagnosis response
 */
export function parseFollowupDiagnosis(
  generatedText: string,
  followupType: FollowupCategoryType
): FollowupDiagnosisResponse {
  return {
    summary: extractSection(generatedText, 'SUMMARY', followupType === 'pillar' ? 'PROGRESS ANALYSIS' : 'IMPLEMENTATION PROGRESS ANALYSIS'),
    situationAnalysis: followupType === 'pillar' ? 
      extractSection(generatedText, 'PROGRESS ANALYSIS', 'IMPLEMENTATION EFFECTIVENESS') :
      extractSection(generatedText, 'IMPLEMENTATION PROGRESS ANALYSIS', 'CROSS-PILLAR INTEGRATION'),
    strengthsAnalysis: followupType === 'pillar' ? 
      extractSection(generatedText, 'IMPLEMENTATION EFFECTIVENESS', 'ADJUSTED RECOMMENDATIONS') :
      extractSection(generatedText, 'CROSS-PILLAR INTEGRATION', 'IMPLEMENTATION BARRIERS'),
    growthAreasAnalysis: followupType === 'pillar' ? 
      extractSection(generatedText, 'ADJUSTED RECOMMENDATIONS', 'CONTINUED GROWTH PLAN') :
      extractSection(generatedText, 'IMPLEMENTATION BARRIERS', 'COMPREHENSIVE ADJUSTMENT PLAN'),
    actionableRecommendations: followupType === 'pillar' ? 
      extractSection(generatedText, 'CONTINUED GROWTH PLAN', 'COACHING SUPPORT ASSESSMENT') :
      extractSection(generatedText, 'COMPREHENSIVE ADJUSTMENT PLAN', 'NEXT FOCUS AREAS'),
    pillarRecommendations: followupType === 'workbook' ? 
      extractSection(generatedText, 'NEXT FOCUS AREAS', 'COACHING SUPPORT ASSESSMENT') : '',
    followupRecommendation: extractSection(generatedText, 'COACHING SUPPORT ASSESSMENT')
  };
}
